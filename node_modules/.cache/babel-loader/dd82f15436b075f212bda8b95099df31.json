{"ast":null,"code":"var _jsxFileName = \"/Users/admin/Downloads/portfolio-master/src/components/Test.js\";\nimport React from 'react'; // https://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/ <----- React lifecycle diagram\n\nexport default class Clock extends React.Component {\n  constructor(props) {\n    // call super or props will be undefined in constructor\n    super(props); // this is the state, do not modify directly because react may\n    // update state and props asynchronously (use setState)\n\n    this.state = {\n      date: new Date()\n    };\n  } // activates when DOM loads (render())\n\n\n  componentDidMount() {\n    this.timerID = setInterval(() => this.tick(), 1000);\n  }\n\n  tick() {\n    // calling setStates lets react know to re-render since\n    // state variable has been updated (with the new date).\n    // if you had other variales inside the dictionary it's ok, will merge.\n    this.setState({\n      date: new Date()\n    });\n  } // when component removed from DOM, stops the interval lifecycle\n\n\n  componentWillUnmount() {\n    clearInterval(this.timerID);\n  } // when component updates (new prop/state). must be enclosed in condition\n  // otherwise will be infinite loop. activates right after update.\n\n\n  componentDidUpdate(prevProps, prevState) {\n    // only activates if pre-update state is same as new one\n    if (this.state === prevState) {\n      console.log(\"did update!\");\n    }\n  } // activates when there are new props or state apart from initial one, just before update.\n  // can compare if prop and state changed, if no, return false for do not update.\n  // only used for performance improvement.\n\n\n  shouldComponentUpdate(nextProp, nextState) {\n    if (this.prop !== nextProp && this.state !== nextState) return true;\n  }\n\n  render() {\n    return /*#__PURE__*/React.createElement(\"div\", {\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 49,\n        columnNumber: 13\n      }\n    }, /*#__PURE__*/React.createElement(\"h1\", {\n      style: {\n        fontSize: \"40px\"\n      },\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 50,\n        columnNumber: 17\n      }\n    }, \"It is \", this.state.date.toLocaleTimeString()));\n  }\n\n}","map":{"version":3,"names":["React","Clock","Component","constructor","props","state","date","Date","componentDidMount","timerID","setInterval","tick","setState","componentWillUnmount","clearInterval","componentDidUpdate","prevProps","prevState","console","log","shouldComponentUpdate","nextProp","nextState","prop","render","fontSize","toLocaleTimeString"],"sources":["/Users/admin/Downloads/portfolio-master/src/components/Test.js"],"sourcesContent":["import React from 'react';\n\n\n// https://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/ <----- React lifecycle diagram\nexport default class Clock extends React.Component{\n    constructor(props){\n        // call super or props will be undefined in constructor\n        super(props);\n        // this is the state, do not modify directly because react may\n        // update state and props asynchronously (use setState)\n        this.state = {date: new Date()};\n    }\n\n    // activates when DOM loads (render())\n    componentDidMount(){\n        this.timerID = setInterval(() => this.tick(), 1000);\n    }\n\n    tick(){\n        // calling setStates lets react know to re-render since\n        // state variable has been updated (with the new date).\n        // if you had other variales inside the dictionary it's ok, will merge.\n        this.setState({date: new Date()});\n    }\n\n    // when component removed from DOM, stops the interval lifecycle\n    componentWillUnmount(){\n        clearInterval(this.timerID);\n    }\n\n    // when component updates (new prop/state). must be enclosed in condition\n    // otherwise will be infinite loop. activates right after update.\n    componentDidUpdate(prevProps, prevState){\n        // only activates if pre-update state is same as new one\n        if(this.state === prevState){\n            console.log(\"did update!\")\n        }\n    }\n    // activates when there are new props or state apart from initial one, just before update.\n    // can compare if prop and state changed, if no, return false for do not update.\n    // only used for performance improvement.\n    shouldComponentUpdate(nextProp, nextState){\n        if(this.prop !== nextProp && this.state !== nextState)\n            return true;\n    }\n\n    render(){\n        return(\n            <div>\n                <h1 style={{fontSize:\"40px\"}}>\n                    It is {this.state.date.toLocaleTimeString()}\n                </h1>\n            </div>\n        )\n    }\n}\n"],"mappings":";AAAA,OAAOA,KAAP,MAAkB,OAAlB,C,CAGA;;AACA,eAAe,MAAMC,KAAN,SAAoBD,KAAK,CAACE,SAA1B,CAAmC;EAC9CC,WAAW,CAACC,KAAD,EAAO;IACd;IACA,MAAMA,KAAN,EAFc,CAGd;IACA;;IACA,KAAKC,KAAL,GAAa;MAACC,IAAI,EAAE,IAAIC,IAAJ;IAAP,CAAb;EACH,CAP6C,CAS9C;;;EACAC,iBAAiB,GAAE;IACf,KAAKC,OAAL,GAAeC,WAAW,CAAC,MAAM,KAAKC,IAAL,EAAP,EAAoB,IAApB,CAA1B;EACH;;EAEDA,IAAI,GAAE;IACF;IACA;IACA;IACA,KAAKC,QAAL,CAAc;MAACN,IAAI,EAAE,IAAIC,IAAJ;IAAP,CAAd;EACH,CAnB6C,CAqB9C;;;EACAM,oBAAoB,GAAE;IAClBC,aAAa,CAAC,KAAKL,OAAN,CAAb;EACH,CAxB6C,CA0B9C;EACA;;;EACAM,kBAAkB,CAACC,SAAD,EAAYC,SAAZ,EAAsB;IACpC;IACA,IAAG,KAAKZ,KAAL,KAAeY,SAAlB,EAA4B;MACxBC,OAAO,CAACC,GAAR,CAAY,aAAZ;IACH;EACJ,CAjC6C,CAkC9C;EACA;EACA;;;EACAC,qBAAqB,CAACC,QAAD,EAAWC,SAAX,EAAqB;IACtC,IAAG,KAAKC,IAAL,KAAcF,QAAd,IAA0B,KAAKhB,KAAL,KAAeiB,SAA5C,EACI,OAAO,IAAP;EACP;;EAEDE,MAAM,GAAE;IACJ,oBACI;MAAA;MAAA;QAAA;QAAA;QAAA;MAAA;IAAA,gBACI;MAAI,KAAK,EAAE;QAACC,QAAQ,EAAC;MAAV,CAAX;MAAA;MAAA;QAAA;QAAA;QAAA;MAAA;IAAA,aACW,KAAKpB,KAAL,CAAWC,IAAX,CAAgBoB,kBAAhB,EADX,CADJ,CADJ;EAOH;;AAlD6C"},"metadata":{},"sourceType":"module"}