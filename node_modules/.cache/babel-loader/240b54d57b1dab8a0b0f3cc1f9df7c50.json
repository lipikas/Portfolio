{"ast":null,"code":"import _classCallCheck from\"/Users/admin/Downloads/portfolio-master/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";import _createClass from\"/Users/admin/Downloads/portfolio-master/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";import _inherits from\"/Users/admin/Downloads/portfolio-master/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";import _createSuper from\"/Users/admin/Downloads/portfolio-master/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper\";import React from'react';// https://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/ <----- React lifecycle diagram\nvar Clock=/*#__PURE__*/function(_React$Component){_inherits(Clock,_React$Component);var _super=_createSuper(Clock);function Clock(props){var _this;_classCallCheck(this,Clock);// call super or props will be undefined in constructor\n_this=_super.call(this,props);// this is the state, do not modify directly because react may\n// update state and props asynchronously (use setState)\n_this.state={date:new Date()};return _this;}// activates when DOM loads (render())\n_createClass(Clock,[{key:\"componentDidMount\",value:function componentDidMount(){var _this2=this;this.timerID=setInterval(function(){return _this2.tick();},1000);}},{key:\"tick\",value:function tick(){// calling setStates lets react know to re-render since\n// state variable has been updated (with the new date).\n// if you had other variales inside the dictionary it's ok, will merge.\nthis.setState({date:new Date()});}// when component removed from DOM, stops the interval lifecycle\n},{key:\"componentWillUnmount\",value:function componentWillUnmount(){clearInterval(this.timerID);}// when component updates (new prop/state). must be enclosed in condition\n// otherwise will be infinite loop. activates right after update.\n},{key:\"componentDidUpdate\",value:function componentDidUpdate(prevProps,prevState){// only activates if pre-update state is same as new one\nif(this.state===prevState){console.log(\"did update!\");}}// activates when there are new props or state apart from initial one, just before update.\n// can compare if prop and state changed, if no, return false for do not update.\n// only used for performance improvement.\n},{key:\"shouldComponentUpdate\",value:function shouldComponentUpdate(nextProp,nextState){if(this.prop!==nextProp&&this.state!==nextState)return true;}},{key:\"render\",value:function render(){return/*#__PURE__*/React.createElement(\"div\",null,/*#__PURE__*/React.createElement(\"h1\",{style:{fontSize:\"40px\"}},\"It is \",this.state.date.toLocaleTimeString()));}}]);return Clock;}(React.Component);export{Clock as default};","map":{"version":3,"names":["React","Clock","props","state","date","Date","timerID","setInterval","tick","setState","clearInterval","prevProps","prevState","console","log","nextProp","nextState","prop","fontSize","toLocaleTimeString","Component"],"sources":["/Users/admin/Downloads/portfolio-master/src/components/Test.js"],"sourcesContent":["import React from 'react';\n\n\n// https://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/ <----- React lifecycle diagram\nexport default class Clock extends React.Component{\n    constructor(props){\n        // call super or props will be undefined in constructor\n        super(props);\n        // this is the state, do not modify directly because react may\n        // update state and props asynchronously (use setState)\n        this.state = {date: new Date()};\n    }\n\n    // activates when DOM loads (render())\n    componentDidMount(){\n        this.timerID = setInterval(() => this.tick(), 1000);\n    }\n\n    tick(){\n        // calling setStates lets react know to re-render since\n        // state variable has been updated (with the new date).\n        // if you had other variales inside the dictionary it's ok, will merge.\n        this.setState({date: new Date()});\n    }\n\n    // when component removed from DOM, stops the interval lifecycle\n    componentWillUnmount(){\n        clearInterval(this.timerID);\n    }\n\n    // when component updates (new prop/state). must be enclosed in condition\n    // otherwise will be infinite loop. activates right after update.\n    componentDidUpdate(prevProps, prevState){\n        // only activates if pre-update state is same as new one\n        if(this.state === prevState){\n            console.log(\"did update!\")\n        }\n    }\n    // activates when there are new props or state apart from initial one, just before update.\n    // can compare if prop and state changed, if no, return false for do not update.\n    // only used for performance improvement.\n    shouldComponentUpdate(nextProp, nextState){\n        if(this.prop !== nextProp && this.state !== nextState)\n            return true;\n    }\n\n    render(){\n        return(\n            <div>\n                <h1 style={{fontSize:\"40px\"}}>\n                    It is {this.state.date.toLocaleTimeString()}\n                </h1>\n            </div>\n        )\n    }\n}\n"],"mappings":"wmBAAA,MAAOA,MAAP,KAAkB,OAAlB,CAGA;GACqBC,M,0GACjB,eAAYC,KAAZ,CAAkB,uCACd;AACA,uBAAMA,KAAN,EACA;AACA;AACA,MAAKC,KAAL,CAAa,CAACC,IAAI,CAAE,GAAIC,KAAJ,EAAP,CAAb,CALc,aAMjB,CAED;mDACA,4BAAmB,iBACf,KAAKC,OAAL,CAAeC,WAAW,CAAC,iBAAM,OAAI,CAACC,IAAL,EAAN,EAAD,CAAoB,IAApB,CAA1B,CACH,C,oBAED,eAAM,CACF;AACA;AACA;AACA,KAAKC,QAAL,CAAc,CAACL,IAAI,CAAE,GAAIC,KAAJ,EAAP,CAAd,EACH,CAED;oCACA,+BAAsB,CAClBK,aAAa,CAAC,KAAKJ,OAAN,CAAb,CACH,CAED;AACA;kCACA,4BAAmBK,SAAnB,CAA8BC,SAA9B,CAAwC,CACpC;AACA,GAAG,KAAKT,KAAL,GAAeS,SAAlB,CAA4B,CACxBC,OAAO,CAACC,GAAR,CAAY,aAAZ,EACH,CACJ,CACD;AACA;AACA;qCACA,+BAAsBC,QAAtB,CAAgCC,SAAhC,CAA0C,CACtC,GAAG,KAAKC,IAAL,GAAcF,QAAd,EAA0B,KAAKZ,KAAL,GAAea,SAA5C,CACI,MAAO,KAAP,CACP,C,sBAED,iBAAQ,CACJ,mBACI,4CACI,0BAAI,KAAK,CAAE,CAACE,QAAQ,CAAC,MAAV,CAAX,WACW,KAAKf,KAAL,CAAWC,IAAX,CAAgBe,kBAAhB,EADX,CADJ,CADJ,CAOH,C,mBAlD8BnB,KAAK,CAACoB,S,SAApBnB,K"},"metadata":{},"sourceType":"module"}